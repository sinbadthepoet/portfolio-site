<script type="module">
  import * as THREE from '/assets/js/threejs/three.module.min.js';

  function init() {
    const container = document.getElementById('viewport');

    // 1. Create the renderer and set its size to the container's current size
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);

    // 2. Append the renderer's DOM element (a <canvas>) into the container div
    container.appendChild(renderer.domElement);

    // 3. Create a camera matching the container's aspect ratio
    const camera = new THREE.PerspectiveCamera(
      75,
      container.clientWidth / container.clientHeight,
      0.1,
      1000
    );
    camera.position.z = 8;

    // 4. Create a scene & simple geometry (example: rotating cube)
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xEFF1F5);

    // Create grid helper
    const size = 50;
    const divisions = 100;
    const gridHelper = new THREE.GridHelper(size, divisions, 0x808080, 0x808080);
    gridHelper.computeLineDistances();
    gridHelper.material = new THREE.LineDashedMaterial({dashSize: 0.015, gapSize: 0.5, vertexColors: true});
    gridHelper.rotation.x = 90;
    scene.add(gridHelper);

    // Create the cube
    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const material = new THREE.MeshNormalMaterial();
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
    cube.position.y = -5;

    // Add ambient light to better see the scene
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // Add directional light for better depth perception
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);

    // Mouse and physics parameters
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let isDragging = false;
    let previousMousePosition = {
      x: 0,
      timestamp: 0
    };
    
    // Rotation physics parameters
    let angularVelocity = 0;
    const friction = 0.95; // Affects how quickly the rotation slows down (0-1)
    const velocityMultiplier = 0.3; // Affects how much "force" initial rotation has
    const minimumVelocity = 0.001; // Velocity threshold to stop rotation

    // Animation parameters
    const targetY = 1;
    const rotationSpeed = 0.02;
    const moveSpeed = 0.02;
    let animationComplete = false;

    // Mouse event handlers
    function onMouseDown(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(cube);
      
      if (intersects.length > 0) {
        isDragging = true;
        previousMousePosition = {
          x: event.clientX,
          timestamp: event.timeStamp
        };
        angularVelocity = 0; // Reset velocity when grabbing
      }
    }

    function onMouseMove(event) {
      if (isDragging && animationComplete) {
        const deltaMove = {
          x: event.clientX - previousMousePosition.x,
          time: event.timeStamp - previousMousePosition.timestamp
        };

        // Calculate instantaneous velocity
        angularVelocity = (deltaMove.x / deltaMove.time) * velocityMultiplier;
        
        // Apply rotation based on mouse movement
        cube.rotation.y += deltaMove.x * 0.01;

        previousMousePosition = {
          x: event.clientX,
          timestamp: event.timeStamp
        };
      }
    }

    function onMouseUp() {
      isDragging = false;
    }

    // Add event listeners
    window.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      // Initial animation to move cube up
      if (!animationComplete && cube.position.y < targetY) {
        cube.position.y += moveSpeed;
        cube.rotation.y += rotationSpeed;
      } else {
        animationComplete = true;

        // Apply inertial rotation when not dragging
        if (!isDragging && Math.abs(angularVelocity) > minimumVelocity) {
          cube.rotation.y += angularVelocity;
          angularVelocity *= friction; // Apply friction
        }
      }

      renderer.render(scene, camera);
    }
    animate();

    // Window resize handler
    window.addEventListener('resize', onWindowResize);

    function onWindowResize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    }
  }

  document.addEventListener('DOMContentLoaded', init);
</script>