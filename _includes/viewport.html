<div class="Viewport" id="viewport">
  <script type="module">

    import * as THREE from '/assets/js/threejs/three.module.min.js';
    import { GLTFLoader } from '/assets/js/GLTFLoader.js';

    /****************************************
     * TUNABLE PARAMETERS (ALL CAPS)
     ****************************************/

    // INTRO ANIMATION (time-based)
    const INTRO_TIME        = 3.0;   // seconds for the intro animation
    const INTRO_Y_START     = -8;
    const INTRO_Y_END       = 0;
    const INTRO_ROT_OFFSET  = -1;    // start rotation offset in radians

    // DRAG & FLING
    const DRAG_ROTATION_SCALE = 0.005; 
    const MAX_VELOCITY        = 0.5;   // clamp fling velocity to avoid extremes
    const MIN_VELOCITY        = 0.001; // if it goes below this, we set it to 0
    const FRICTION            = 0.9;   // how quickly fling speed decays

    // TURNTABLE SPEED in RPM:
    // If fling velocity is above this, friction eventually decays it to that speed, then it keeps spinning.
    // Otherwise friction to 0.
    const TURNTABLE_RPM      = 6.0;

    // CAMERA
    const CAMERA_Z           = 6.2;

    /****************************************
     * HELPER: convert RPM to radians/frame
     ****************************************/
    function rpmToRadPerFrame(rpm) {
      // 1 rotation = 2π radians
      // rpm * 2π => radians/min
      // / 60 => radians/sec, / 60 => radians/frame @ ~60 fps
      return (rpm * 2 * Math.PI) / (60 * 60);
    }
    const TURNTABLE_SPEED = rpmToRadPerFrame(TURNTABLE_RPM);

    function init() {
      const container = document.getElementById('viewport');

      // RENDERER
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setClearColor(0x000000, 0);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);
    
      // CAMERA
      const camera = new THREE.PerspectiveCamera(
        75,
        container.clientWidth / container.clientHeight,
        0.1,
        1000
      );
      camera.position.z = CAMERA_Z;

      // SCENE
      const scene = new THREE.Scene();

      // LIGHTING
      const directionalLight = new THREE.DirectionalLight(0xEFF1F5, 8.0);
      directionalLight.position.set(10, 10, 10);
      scene.add(directionalLight);

      const directionalLight2 = new THREE.DirectionalLight(0xEFF1F5, 2.18);
      directionalLight2.position.set(-7, 0, 5);
      scene.add(directionalLight2);

      // MODEL
      let Model = null;
      const modelName = "{{ page.model | default: 'Head' }}";
      const modelUrl = `/assets/models/${modelName}.glb`;
      const normalUrl = `/assets/models/${modelName}.png`;

      // TEXTURE LOADER
      const textureLoader = new THREE.TextureLoader();
      const normalMap = textureLoader.load(normalUrl);

      const ModelLoader = new GLTFLoader();
      ModelLoader.load(modelUrl, function (gltf) {
        Model = gltf.scene;
        
        // Apply normal map to all materials
        Model.traverse((child) => {
          if (child.isMesh && child.material) {
            child.material.normalMap = normalMap;
            child.material.needsUpdate = true;
          }
        });

        // Start transforms
        Model.position.y = INTRO_Y_START;
        Model.rotation.y = INTRO_ROT_OFFSET;
        Model.scale.set(0.9, 0.9, 0.9);

        scene.add(Model);
      }, undefined, function (error) {
        console.error(error);
      });

      // INTRO TIMING
      let introStartTime = null;
      let animationComplete = false;

      // DRAG/FLING
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let isDragging = false;
      let previousMousePosition = { x: 0, timestamp: 0 };
      
      // We'll track fling velocity
      let angularVelocity = 0;

      // We'll track if we plan to clamp to turntable after friction
      let shouldClampToTurntable = false;

      // HELPERS
      function clamp01(x) {
        return Math.min(1, Math.max(0, x));
      }
      function easeOutQuad(t) {
        return 1 - (1 - t) * (1 - t);
      }

      // MOUSE POSITION
      function getMousePosition(event) {
        const rect = container.getBoundingClientRect();
        return {
          x: ((event.clientX - rect.left) / rect.width) * 2 - 1,
          y: -((event.clientY - rect.top) / rect.height) * 2 + 1
        };
      }

      // MOUSE EVENT HANDLERS
      function onMouseDown(event) {
        if (!Model || !animationComplete) return;

        // Check if user clicked on the model
        const mousePos = getMousePosition(event);
        mouse.x = mousePos.x;
        mouse.y = mousePos.y;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObject(Model, true);

        if (intersects.length > 0) {
          isDragging = true;
          previousMousePosition = {
            x: event.clientX,
            timestamp: event.timeStamp
          };
          // Reset fling velocity
          angularVelocity = 0;
        }
      }

      function onMouseMove(event) {
        if (isDragging && Model) {
          const deltaX = event.clientX - previousMousePosition.x;

          // Immediate rotation with dragging
          Model.rotation.y += deltaX * DRAG_ROTATION_SCALE;

          // Calculate fling velocity
          let flingVel = deltaX * DRAG_ROTATION_SCALE;
          if (Math.abs(flingVel) > MAX_VELOCITY) {
            flingVel = Math.sign(flingVel) * MAX_VELOCITY;
          }
          angularVelocity = flingVel;

          previousMousePosition = {
            x: event.clientX,
            timestamp: event.timeStamp
          };
        }
      }

      function onMouseUp() {
        if (!Model || !isDragging) return;
        isDragging = false;

        // We'll do friction after let go, but we note if we plan to clamp
        // If fling velocity is above threshold, we eventually clamp to it
        // else friction to 0
        if (Math.abs(angularVelocity) >= TURNTABLE_SPEED) {
          shouldClampToTurntable = true;
        } else {
          shouldClampToTurntable = false;
        }
      }

      container.addEventListener('mousedown', onMouseDown);
      container.addEventListener('mousemove', onMouseMove);
      window.addEventListener('mouseup', onMouseUp);

      // ANIMATION LOOP
      function animate() {
        requestAnimationFrame(animate);

        // Mark the intro start time on first frame
        if (!introStartTime) {
          introStartTime = performance.now();
        }

        if (Model) {
          // 1) TIME-BASED INTRO
          if (!animationComplete) {
            const elapsed = (performance.now() - introStartTime) / 1000;
            let t = clamp01(elapsed / INTRO_TIME);
            t = easeOutQuad(t);

            // Lerp position.y
            const totalYDist = INTRO_Y_END - INTRO_Y_START;
            Model.position.y = INTRO_Y_START + totalYDist * t;

            // Lerp rotation from INTRO_ROT_OFFSET to 0
            Model.rotation.y = INTRO_ROT_OFFSET + (0 - INTRO_ROT_OFFSET) * t;

            if (elapsed >= INTRO_TIME) {
              Model.position.y = INTRO_Y_END;
              Model.rotation.y = 0;
              animationComplete = true;
            }
          }
          // 2) POST-INTRO BEHAVIOR
          else {
            // Only apply friction if not dragging
            if (!isDragging) {
              // Multiply velocity by friction
              angularVelocity *= FRICTION;

              // If we plan to clamp to turntable
              if (shouldClampToTurntable) {
                // Once we cross below turntable speed, clamp to it
                if (Math.abs(angularVelocity) < TURNTABLE_SPEED) {
                  angularVelocity = Math.sign(angularVelocity) * TURNTABLE_SPEED;
                  // (Now the model will keep spinning indefinitely at that speed.)
                }
              } else {
                // If not clamping, friction eventually goes to 0
                if (Math.abs(angularVelocity) < MIN_VELOCITY) {
                  angularVelocity = 0;
                }
              }

              // Finally, apply rotation
              Model.rotation.y += angularVelocity;
            }
          }
        }

        renderer.render(scene, camera);
      }
      animate();

      // RESIZE
      window.addEventListener('resize', onWindowResize);
      function onWindowResize() {
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
      }
    }

    // HOOKS
    document.addEventListener('DOMContentLoaded', init);
    barba.hooks.after(init);

  </script>
</div>
