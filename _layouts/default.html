<!doctype html>
<html>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Playwrite+GB+S:ital,wght@0,100..400;1,100..400&display=swap" rel="stylesheet">
  <head>
    {% include head.html %}
  </head>
  <body data-barba="wrapper">
    {{ content }}
    <script type="module">
      //HANGER

      import * as THREE from '/assets/js/threejs/three.module.min.js';
      import { GLTFLoader } from '/assets/js/GLTFLoader.js';
      
      function init() {
        const container = document.getElementById('hanger');

        if(container == null){
          return;
        }
  
        // RENDERER
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientHeight * 1.2, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);
      
        // CAMERA
        const camera = new THREE.OrthographicCamera(
          -12 * 1.2, 12 * 1.2,
          12, -12,
          1, 1000
        );
        camera.position.x = 29;
        camera.position.y = 17.5;
        camera.position.z = 32;
        camera.rotation.x = -16 * (Math.PI / 180);
        camera.rotation.y = 40 * (Math.PI / 180);
        camera.rotation.z = 11 * (Math.PI / 180);
        
  
        // SCENE
        const scene = new THREE.Scene();
  
        // LIGHTING
        const directionalLight = new THREE.DirectionalLight(0xEFF1F5, 2);
        directionalLight.position.set(5, 30, 30);
        directionalLight.castShadow = true;
        
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.bias = -0.0006;
        
        //const shadowHelper = new THREE.CameraHelper(directionalLight.shadow.camera);

        scene.add(directionalLight);
        //scene.add(shadowHelper);
  
        const ambientLight = new THREE.AmbientLight(0xEFF1F5, 2);
        scene.add(ambientLight);

        const planeGeometry = new THREE.PlaneGeometry(20, 25);
        const planeMaterial = new THREE.ShadowMaterial();

        planeMaterial.opacity = 0.2;

        const plane = new THREE.Mesh(planeGeometry, planeMaterial);

        // Rotate the plane to be horizontal
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        plane.position.z = -8;

        // Add the plane to the scene
        scene.add(plane);
  
        // MODEL
        let Head = null;
        let Core = null;
        let Arms = null;
        let Legs = null;
  
        const cast = true;
        const recv = true;

        const ModelLoader = new GLTFLoader();

        ModelLoader.load('/assets/models/Full/Head.glb', function (gltf) {
          Head = gltf.scene;

          Head.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = cast;
              child.receiveShadow = recv;
            }
          });
  
          scene.add(Head);
        }, undefined, function (error) {
          console.error(error);
        });

        ModelLoader.load('/assets/models/Full/Core.glb', function (gltf) {
          Core = gltf.scene;
  
          Core.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = cast;
              child.receiveShadow = recv;
            }
          });

          scene.add(Core);
        }, undefined, function (error) {
          console.error(error);
        });

        ModelLoader.load('/assets/models/Full/Arms.glb', function (gltf) {
          Arms = gltf.scene;
  
          Arms.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = cast;
              child.receiveShadow = recv;
            }
          });

          scene.add(Arms);
        }, undefined, function (error) {
          console.error(error);
        });

        ModelLoader.load('/assets/models/Full/Legs.glb', function (gltf) {
          Legs = gltf.scene;
  
          Legs.traverse((child) => {
            if (child.isMesh) {
              child.castShadow = cast;
              child.receiveShadow = recv;
            }
          });

          scene.add(Legs);
        }, undefined, function (error) {
          console.error(error);
        });
  
        // RESIZE
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
          const w = container.clientWidth;
          const h = container.clientHeight;
          renderer.setSize(w, h);
          
          container.clientWidth / - 64, container.clientWidth / 64,
          container.clientHeight / 64, container.clientHeight / - 64

          camera.left = -w / 64;
          camera.right = w / 64;
          camera.top = h / 64;
          camera.bottom = -h / 64;


          camera.updateProjectionMatrix();
        }

        function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
        }

        animate(); // Start rendering

      }
  
      // HOOKS
      document.addEventListener('DOMContentLoaded', init);
      barba.hooks.after(init);
  
      let lastFrameTime = performance.now();
      const frameTimes = [];
      const maxSamples = 10; // Adjust this for more smoothing
  
      function updateFrameTime() {
          const now = performance.now();
          const frameTime = now - lastFrameTime;
          lastFrameTime = now;
  
          // Store the frame time
          frameTimes.push(frameTime);
  
          // Keep the sample size small for recent smoothing
          if (frameTimes.length > maxSamples) {
              frameTimes.shift(); // Remove the oldest value
          }
  
          // Compute the average
          const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
  
          // Update the DOM element
          document.getElementById('frameGenTime').textContent = `Frame Gen Time: ${avgFrameTime.toFixed(1)}ms`;
  
          requestAnimationFrame(updateFrameTime);
      }
  
      // Start tracking frame time
      requestAnimationFrame(updateFrameTime);
    </script>
    <script type="module">
      //LIMB
      import * as THREE from '/assets/js/threejs/three.module.min.js';
      import { GLTFLoader } from '/assets/js/GLTFLoader.js';
  
      /****************************************
       * TUNABLE PARAMETERS (ALL CAPS)
       ****************************************/
  
      // INTRO ANIMATION (time-based)
      const INTRO_TIME        = 3.0;   // seconds for the intro animation
      const INTRO_Y_START     = -8;
      const INTRO_Y_END       = 0;
      const INTRO_ROT_OFFSET  = -1;    // start rotation offset in radians
  
      // DRAG & FLING
      const DRAG_ROTATION_SCALE = 0.005; 
      const MAX_VELOCITY        = 0.5;   // clamp fling velocity to avoid extremes
      const MIN_VELOCITY        = 0.001; // if it goes below this, we set it to 0
      const FRICTION            = 0.9;   // how quickly fling speed decays
  
      // TURNTABLE SPEED in RPM:
      // If fling velocity is above this, friction eventually decays it to that speed, then it keeps spinning.
      // Otherwise friction to 0.
      const TURNTABLE_RPM      = 6.0;
  
      // CAMERA
      const CAMERA_Z           = 15;
  
      /****************************************
       * HELPER: convert RPM to radians/frame
       ****************************************/
      function rpmToRadPerFrame(rpm) {
        // 1 rotation = 2π radians
        // rpm * 2π => radians/min
        // / 60 => radians/sec, / 60 => radians/frame @ ~60 fps
        return (rpm * 2 * Math.PI) / (60 * 60);
      }
      const TURNTABLE_SPEED = rpmToRadPerFrame(TURNTABLE_RPM);
  
      function init() {
        const container = document.getElementById('viewport');

        if(container == null){
          return;
        }
  
        // RENDERER
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientWidth * 2, container.clientHeight);
        container.appendChild(renderer.domElement);
      
        // CAMERA
        const camera = new THREE.PerspectiveCamera(
          30,
          container.clientWidth * 2 / container.clientHeight,
          0.1,
          1000
        );
        camera.position.z = CAMERA_Z;
  
        // SCENE
        const scene = new THREE.Scene();
  
        // LIGHTING
        const directionalLight = new THREE.DirectionalLight(0xEFF1F5, 3.64);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);
  
        const ambientLight = new THREE.AmbientLight(0xEFF1F5, 1.2);
        scene.add(ambientLight);
  
        // MODEL
        let Model = null;
        const modelName = "{{ page.model | default: 'Head' }}";
        const modelUrl = `/assets/models/${modelName}.glb`;
  
        const ModelLoader = new GLTFLoader();
        ModelLoader.load(modelUrl, function (gltf) {
          Model = gltf.scene;
  
          // Start transforms
          Model.position.y = INTRO_Y_START;
          Model.rotation.y = INTRO_ROT_OFFSET;
          Model.scale.set(0.9, 0.9, 0.9);
  
          scene.add(Model);
        }, undefined, function (error) {
          console.error(error);
        });
  
        // INTRO TIMING
        let introStartTime = null;
        let animationComplete = false;
  
        // DRAG/FLING
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, timestamp: 0 };
        
        // We'll track fling velocity
        let angularVelocity = 0;
  
        // We'll track if we plan to clamp to turntable after friction
        let shouldClampToTurntable = false;
  
        // HELPERS
        function clamp01(x) {
          return Math.min(1, Math.max(0, x));
        }
        function easeOutQuad(t) {
          return 1 - (1 - t) * (1 - t);
        }
  
        // MOUSE POSITION
        function getMousePosition(event) {
          const rect = container.getBoundingClientRect();
          return {
            x: ((event.clientX - rect.left) / rect.width) * 2 - 1,
            y: -((event.clientY - rect.top) / rect.height) * 2 + 1
          };
        }
  
        // MOUSE EVENT HANDLERS
        function onMouseDown(event) {
          if (!Model || !animationComplete) return;
  
          // Check if user clicked on the model
          const mousePos = getMousePosition(event);
          mouse.x = mousePos.x;
          mouse.y = mousePos.y;
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(Model, true);
  
          if (intersects.length > 0) {
            isDragging = true;
            previousMousePosition = {
              x: event.clientX,
              timestamp: event.timeStamp
            };
            // Reset fling velocity
            angularVelocity = 0;
          }
        }
  
        function onMouseMove(event) {
          if (isDragging && Model) {
            const deltaX = event.clientX - previousMousePosition.x;
  
            // Immediate rotation with dragging
            Model.rotation.y += deltaX * DRAG_ROTATION_SCALE;
  
            // Calculate fling velocity
            let flingVel = deltaX * DRAG_ROTATION_SCALE;
            if (Math.abs(flingVel) > MAX_VELOCITY) {
              flingVel = Math.sign(flingVel) * MAX_VELOCITY;
            }
            angularVelocity = flingVel;
  
            previousMousePosition = {
              x: event.clientX,
              timestamp: event.timeStamp
            };
          }
        }
  
        function onMouseUp() {
          if (!Model || !isDragging) return;
          isDragging = false;
  
          // We'll do friction after let go, but we note if we plan to clamp
          // If fling velocity is above threshold, we eventually clamp to it
          // else friction to 0
          if (Math.abs(angularVelocity) >= TURNTABLE_SPEED) {
            shouldClampToTurntable = true;
          } else {
            shouldClampToTurntable = false;
          }
        }
  
        container.addEventListener('mousedown', onMouseDown);
        container.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
  
        container.addEventListener('touchstart', onMouseDown);
        container.addEventListener('touchmove', onMouseMove);
        window.addEventListener('touchend', onMouseUp);
  
  
        // ANIMATION LOOP
        function animate() {
          requestAnimationFrame(animate);
  
          // Mark the intro start time on first frame
          if (!introStartTime) {
            introStartTime = performance.now();
          }
  
          if (Model) {
            // 1) TIME-BASED INTRO
            if (!animationComplete) {
              const elapsed = (performance.now() - introStartTime) / 1000;
              let t = clamp01(elapsed / INTRO_TIME);
              t = easeOutQuad(t);
  
              // Lerp position.y
              const totalYDist = INTRO_Y_END - INTRO_Y_START;
              Model.position.y = INTRO_Y_START + totalYDist * t;
  
              // Lerp rotation from INTRO_ROT_OFFSET to 0
              Model.rotation.y = INTRO_ROT_OFFSET + (0 - INTRO_ROT_OFFSET) * t;
  
              if (elapsed >= INTRO_TIME) {
                Model.position.y = INTRO_Y_END;
                Model.rotation.y = 0;
                animationComplete = true;
              }
            }
            // 2) POST-INTRO BEHAVIOR
            else {
              // Only apply friction if not dragging
              if (!isDragging) {
                // Multiply velocity by friction
                angularVelocity *= FRICTION;
  
                // If we plan to clamp to turntable
                if (shouldClampToTurntable) {
                  // Once we cross below turntable speed, clamp to it
                  if (Math.abs(angularVelocity) < TURNTABLE_SPEED) {
                    angularVelocity = Math.sign(angularVelocity) * TURNTABLE_SPEED;
                    // (Now the model will keep spinning indefinitely at that speed.)
                  }
                } else {
                  // If not clamping, friction eventually goes to 0
                  if (Math.abs(angularVelocity) < MIN_VELOCITY) {
                    angularVelocity = 0;
                  }
                }
  
                // Finally, apply rotation
                Model.rotation.y += angularVelocity;
              }
            }
          }
  
          renderer.render(scene, camera);
        }
        animate();
  
        // RESIZE
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
          const w = container.clientWidth;
          const h = container.clientHeight;
          renderer.setSize(w, h);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        }
      }
  
      // HOOKS
      document.addEventListener('DOMContentLoaded', init);
      barba.hooks.after(init);
  
      let lastFrameTime = performance.now();
      const frameTimes = [];
      const maxSamples = 10; // Adjust this for more smoothing
  
      function updateFrameTime() {
          const now = performance.now();
          const frameTime = now - lastFrameTime;
          lastFrameTime = now;
  
          // Store the frame time
          frameTimes.push(frameTime);
  
          // Keep the sample size small for recent smoothing
          if (frameTimes.length > maxSamples) {
              frameTimes.shift(); // Remove the oldest value
          }
  
          // Compute the average
          const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
  
          // Update the DOM element
          document.getElementById('frameGenTime').textContent = `Frame Gen Time: ${avgFrameTime.toFixed(1)}ms`;
  
          requestAnimationFrame(updateFrameTime);
      }
  
      // Start tracking frame time
      requestAnimationFrame(updateFrameTime);
  
    </script>
  </body>
</html>