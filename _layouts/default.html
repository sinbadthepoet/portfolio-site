<!doctype html>
<html>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Playwrite+GB+S:ital,wght@0,100..400;1,100..400&display=swap" rel="stylesheet">
  <head>
    {% include head.html %}
  </head>
  <body data-barba="wrapper">
    {{ content }}
    <script type="module">
      //IMPORTS
      import * as THREE from '/assets/js/threejs/three.module.min.js';
      import { GLTFLoader } from '/assets/js/GLTFLoader.js';
      
      //VARIABLES
      let container;
      let renderer, camera, scene;
      let waypointContainer, svgOverlay;
      let raycaster, mouse;
      let hoveredPart = null;  

      const markers = [];
      const clickableMeshes = [];
      const materials = [];
      
      //PARAMS
      const DEFAULT_MESH_COLOR = new THREE.Color(0xe7e7e7); 
      const NON_HOVERED_MESH_COLOR = new THREE.Color(0xa2a2a2); 

      const viewHeight = 20;

      let lastColorUpdateTime;

      const WAYPOINT_PARAMS = {
        fontFamily: 'Inter, sans-serif',
        fontWeight: 'bold',
        fontSize: '2rem',
        textColor: '#666',
        underlineThickness: '2px',
        transitionTime: 0.3,
        nonHighlightOpacity: 0.3
      };

      const pageMapping = {
        head: "/limbs/head.html",
        core: "/limbs/chest.html",
        arms: "/limbs/arms.html",
        legs: "/limbs/legs.html"
      };

      //INTERNAL FUNCTIONS
      function navigateTo(url) {
        if (typeof barba !== 'undefined' && typeof barba.go === 'function') {
          barba.go(url);
        } else {
          window.location.href = url;
        }
      }

      function processModel(gltf, partName) {
        const group = gltf.scene;
        group.traverse(child => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            child.material.color.set(0xe7e7e7);
            child.userData.part = partName;
            clickableMeshes.push(child);
          }
        });
        scene.add(group);
        return group;
      }
      
      ////IMPLEMENT LINES////
      function createWaypointMarker(text, textPos, lineTarget, alignment = 'center', assoc) {
        //Position is set in the UpdateWaypoint function

        const marker = { text, textPos, lineTarget, alignment, assoc };
        const markerDiv = document.createElement('div');
        
        markerDiv.classList.add('waypoint-marker');
        markerDiv.textContent = text;
        
        markerDiv.style.fontFamily = WAYPOINT_PARAMS.fontFamily;
        markerDiv.style.fontWeight = WAYPOINT_PARAMS.fontWeight;
        markerDiv.style.fontSize = WAYPOINT_PARAMS.fontSize;
        markerDiv.style.color = WAYPOINT_PARAMS.textColor;
        
        markerDiv.style.borderBottom = `${WAYPOINT_PARAMS.underlineThickness} solid ${WAYPOINT_PARAMS.textColor}`;
        
        markerDiv.style.textAlign = alignment;
        
        markerDiv.style.position = 'absolute';
        
        markerDiv.style.cursor = 'pointer';
        markerDiv.style.transition = `opacity ${WAYPOINT_PARAMS.transitionTime}s`;
        
        markerDiv.addEventListener('mouseenter', (e) => {
          hoveredPart = marker.assoc;
          updateWaypointStyles();
          document.getElementById('hanger').style.cursor = 'pointer';
        });
        markerDiv.addEventListener('mouseleave', (e) => {
          hoveredPart = null;
          updateWaypointStyles();
          document.getElementById('hanger').style.cursor = 'default';
        });
        markerDiv.addEventListener('click', (e) => {
          e.stopPropagation();
          navigateTo(pageMapping[marker.assoc]);
        });

        waypointContainer.appendChild(markerDiv);
        marker.element = markerDiv;
        
        markers.push(marker);
        /*
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        
        line.setAttribute('stroke', WAYPOINT_PARAMS.underlineColor);
        
        line.style.transition = `opacity ${WAYPOINT_PARAMS.opacityTransitionTime}s`;
        
        line.setAttribute('stroke-width', WAYPOINT_PARAMS.underlineThickness.replace('px',''));
        
        line.style.opacity = '1';
        svgOverlay.appendChild(line);
        marker.lineElement = line;
        */
      }

      ////IMPLEMENT LINE////
      function updateWaypointMarkers() {
        const containerElem = document.getElementById('hanger');
        const cW = containerElem.clientWidth;
        const cH = containerElem.clientHeight;

        //Since the camera is of a fixed height, we need to place these markers based
        //on the container's vertical size.
        markers.forEach(marker => {
          //Make the position values relative to the container height.
          let textPosY = marker.textPos.y * cH;
          let textPosX = marker.textPos.x * cH;

          //Make the position relative to the vertical center line of the div.
          textPosX = textPosX + cW / 2;
          
          //Change Position Based on Alignment
          const markerWidth = marker.element.offsetWidth;

          switch(marker.alignment) {
            case 'left':
              break;
            case 'right':
              textPosX -= markerWidth;
              break;
            default:
              //Center
              textPosX -= markerWidth / 2;              
          }
          
          marker.element.style.transform = `translate(${textPosX}px, ${textPosY}px)`;
        });
        /*
          
          const textCenterX = marker.textCenter.x * containerWidth;
          const textCenterY = marker.textCenter.y * containerHeight;
          const lineTargetX = marker.lineTarget.x * containerWidth;
          const lineTargetY = marker.lineTarget.y * containerHeight;
          
          
          
          let startX;
          if (marker.alignment === 'left') {
            startX = left; 
          } else if (marker.alignment === 'right') {
            startX = left + width; 
          } else { 
            startX = left + width / 2; 
          }
          const startY = top + height; 
          
          marker.lineElement.setAttribute('x1', startX);
          marker.lineElement.setAttribute('y1', startY);
          marker.lineElement.setAttribute('x2', lineTargetX);
          marker.lineElement.setAttribute('y2', lineTargetY);
        });
        */
      }
      
      ////IMPLEMENT LINE////
      function updateWaypointStyles() {
        markers.forEach(marker => {
          //If this is the part we're hovering over
          if (hoveredPart && marker.assoc === hoveredPart) {
            marker.element.style.opacity = 1;
            marker.element.style.color = "#000";
            //marker.lineElement.style.opacity = 1;
          //If a part is being hovered over, but not this one.
          } else if (hoveredPart) {
            marker.element.style.opacity = WAYPOINT_PARAMS.nonHighlightOpacity;
            marker.element.style.color = WAYPOINT_PARAMS.textColor;
            //marker.lineElement.style.opacity = 0.3;
          } else {
            marker.element.style.opacity = 1;
            marker.element.style.color = WAYPOINT_PARAMS.textColor;
            //marker.lineElement.style.opacity = 1;
          }
        });
      }
      
      function updateMeshColors() {
        const now = performance.now();
        let delta = now - lastColorUpdateTime;
        const accessedMaterials = [];
        
        let lerpFactor = delta / (WAYPOINT_PARAMS.transitionTime * 1000);
        if (lerpFactor > 1) lerpFactor = 1;
    
        clickableMeshes.forEach(mesh => {
          let target;
          if (!hoveredPart || mesh.userData.part === hoveredPart) {
            target = DEFAULT_MESH_COLOR;
          } else {
            target = NON_HOVERED_MESH_COLOR;
          }
          if (!accessedMaterials.includes(mesh.material)) {
            console.log(accessedMaterials);
            mesh.material.color.lerp(target, lerpFactor);
            accessedMaterials.push(mesh.material);
          }
        });
        lastColorUpdateTime = now;
      }

      //EVENTS
      function onWindowResize() {
        const w = container.clientWidth;
        const h = container.clientHeight;
        renderer.setSize(w, h);
        
        const aspect = w / h;
        const viewWidth = viewHeight * aspect;

        camera.left = -viewWidth / 2;
        camera.right = viewWidth / 2;
        camera.top = viewHeight / 2;
        camera.bottom = -viewHeight / 2;

        camera.updateProjectionMatrix();
        updateWaypointMarkers();
      }

      function onMouseMove(event) {
        if (event.target.classList.contains('waypoint-marker')) {
          return;
        }
        const containerElem = document.getElementById('hanger');
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(clickableMeshes, true);
        if (intersects.length > 0) {
          const intersected = intersects[0].object;
          const part = intersected.userData.part;
          if (hoveredPart !== part) {
            hoveredPart = part;
            updateWaypointStyles();
          }
          containerElem.style.cursor = 'pointer';
        } else {
          hoveredPart = null;
          updateWaypointStyles();
          containerElem.style.cursor = 'default';
        }
      }
      
      function onMouseClick(event) {
        if (event.target.classList.contains('waypoint-marker')) {
          return;
        }
        if (hoveredPart) {
          navigateTo(pageMapping[hoveredPart]);
        }
      }

      //INIT AND ANIMATION LOOP
      function init(){
        container = document.getElementById('hanger');
        if (!container) return;

        //RENDERER
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true});
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        //CAMERA
        const viewHeight = 20;
        const aspect = container.clientWidth / container.clientHeight;
        const viewWidth = viewHeight * aspect;

        camera = new THREE.OrthographicCamera(
          -viewWidth / 2, viewWidth / 2,
          viewHeight / 2, -viewHeight / 2,
          1, 1000
        );
        camera.position.set(28, 17.5, 32);
        camera.rotation.x = -16 * (Math.PI / 180);
        camera.rotation.y = 40 * (Math.PI / 180);
        camera.rotation.z = 11 * (Math.PI / 180);

        //SCENE
        scene = new THREE.Scene();

        //LIGHTING
        const ambientLight = new THREE.AmbientLight(0xEFF1F5, 2);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xEFF1F5, 2);
        directionalLight.position.set(5, 30, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.bias = -0.0006;
        scene.add(directionalLight);
    
        //ENVIRONMENT
        const planeGeometry = new THREE.PlaneGeometry(20, 25);
        const planeMaterial = new THREE.ShadowMaterial();
        planeMaterial.opacity = 0.2;
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        plane.position.z = -8;
        scene.add(plane);

        //MODEL
        let Head = null, Core = null, Arms = null, Legs = null;

        const ModelLoader = new GLTFLoader();
    
        ModelLoader.load('/assets/models/Full/Head.glb', function (gltf) {
          Head = processModel(gltf, 'head');
        }, undefined, function (error) { console.error(error); });
    
        ModelLoader.load('/assets/models/Full/Core.glb', function (gltf) {
          Core = processModel(gltf, 'core');
        }, undefined, function (error) { console.error(error); });
    
        ModelLoader.load('/assets/models/Full/Arms.glb', function (gltf) {
          Arms = processModel(gltf, 'arms');
        }, undefined, function (error) { console.error(error); });
    
        ModelLoader.load('/assets/models/Full/Legs.glb', function (gltf) {
          Legs = processModel(gltf, 'legs');
        }, undefined, function (error) { console.error(error); });

        //WAYPOINT TAG INIT
        WaypointInit();
        
        //Interactivity
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        container.addEventListener('mousemove', onMouseMove, false);
        container.addEventListener('click', onMouseClick, false);

        //SET UP EVENT HOOKS
        window.addEventListener('resize', onWindowResize);

        //SET UP ANIMATION LOOP
        animate();
      }

      function animate(){
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
        updateWaypointMarkers();
        updateMeshColors();
      }

      function WaypointInit(){
        waypointContainer = document.createElement('div');
        waypointContainer.id = 'waypointContainer';
        waypointContainer.style.position = 'absolute';
        waypointContainer.style.top = '0';
        waypointContainer.style.left = '0';
        waypointContainer.style.width = '100%';
        waypointContainer.style.height = '100%';
        
        container.appendChild(waypointContainer);

        // svgOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        // svgOverlay.id = 'svgOverlay';
        // svgOverlay.style.position = 'absolute';
        // svgOverlay.style.top = '0';
        // svgOverlay.style.left = '0';
        // svgOverlay.style.width = '100%';
        // svgOverlay.style.height = '100%';
        // svgOverlay.style.pointerEvents = 'none';

        // container.appendChild(svgOverlay);

        createWaypointMarker('About Me', { x: 0.2, y: 0 }, { x: 0, y: 0 }, 'center', 'head');
        createWaypointMarker('Game Design', { x: -0.2, y: 0.2 }, { x: 0, y: 0 }, 'center', 'core');
        createWaypointMarker('Narrative Design', { x: 0, y: 0.4 }, { x: 0, y: 0 }, 'center', 'arms');
        createWaypointMarker('Technical Foundations', { x: 0, y: 0.8 }, { x: 0, y: 0 }, 'center', 'legs');
      }

      document.addEventListener('DOMContentLoaded', init);
      barba.hooks.after(init);

      //Exposed Info Code
      let lastFrameTime = performance.now();
      const frameTimes = [];
      const maxSamples = 10;

      function updateFrameTime() {
        const now = performance.now();
        const frameTime = now - lastFrameTime;
        lastFrameTime = now;
        frameTimes.push(frameTime);
        if (frameTimes.length > maxSamples) {
          frameTimes.shift();
        }
        const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
        document.getElementById('frameGenTime').textContent = `Frame Gen Time: ${avgFrameTime.toFixed(1)}ms`;
        requestAnimationFrame(updateFrameTime);
      }
      requestAnimationFrame(updateFrameTime);
    </script>
            
    <script type="module">
      
      import * as THREE from '/assets/js/threejs/three.module.min.js';
      import { GLTFLoader } from '/assets/js/GLTFLoader.js';
  
      /****************************************
       * TUNABLE PARAMETERS (ALL CAPS)
       ****************************************/
  
      
      const INTRO_TIME        = 3.0;   
      const INTRO_Y_START     = -8;
      const INTRO_Y_END       = 0;
      const INTRO_ROT_OFFSET  = -1;    
  
      
      const DRAG_ROTATION_SCALE = 0.005; 
      const MAX_VELOCITY        = 0.5;   
      const MIN_VELOCITY        = 0.001; 
      const FRICTION            = 0.9;   
  
      
      
      
      const TURNTABLE_RPM      = 6.0;
  
      
      const CAMERA_Z           = 15;
  
      /****************************************
       * HELPER: convert RPM to radians/frame
       ****************************************/
      function rpmToRadPerFrame(rpm) {
        
        
        
        return (rpm * 2 * Math.PI) / (60 * 60);
      }
      const TURNTABLE_SPEED = rpmToRadPerFrame(TURNTABLE_RPM);
  
      function init() {
        const container = document.getElementById('viewport');

        if(container == null){
          return;
        }
  
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientWidth * 2, container.clientHeight);
        container.appendChild(renderer.domElement);
      
        
        const camera = new THREE.PerspectiveCamera(
          30,
          container.clientWidth * 2 / container.clientHeight,
          0.1,
          1000
        );
        camera.position.z = CAMERA_Z;
  
        
        const scene = new THREE.Scene();
  
        
        const directionalLight = new THREE.DirectionalLight(0xEFF1F5, 3.64);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);
  
        const ambientLight = new THREE.AmbientLight(0xEFF1F5, 1.2);
        scene.add(ambientLight);
  
        
        let Model = null;

        const modelName = container.getAttribute('data-model') || "Head";
        const modelUrl = `/assets/models/${modelName}.glb`;
  
        const ModelLoader = new GLTFLoader();
        ModelLoader.load(modelUrl, function (gltf) {
          Model = gltf.scene;
  
          
          Model.position.y = INTRO_Y_START;
          Model.rotation.y = INTRO_ROT_OFFSET;
          Model.scale.set(0.9, 0.9, 0.9);
  
          scene.add(Model);
        }, undefined, function (error) {
          console.error(error);
        });
  
        
        let introStartTime = null;
        let animationComplete = false;
  
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, timestamp: 0 };
        
        
        let angularVelocity = 0;
  
        
        let shouldClampToTurntable = false;
  
        
        function clamp01(x) {
          return Math.min(1, Math.max(0, x));
        }
        function easeOutQuad(t) {
          return 1 - (1 - t) * (1 - t);
        }
  
        
        function getMousePosition(event) {
          const rect = container.getBoundingClientRect();
          return {
            x: ((event.clientX - rect.left) / rect.width) * 2 - 1,
            y: -((event.clientY - rect.top) / rect.height) * 2 + 1
          };
        }
  
        
        function onMouseDown(event) {
          if (!Model || !animationComplete) return;
  
          
          const mousePos = getMousePosition(event);
          mouse.x = mousePos.x;
          mouse.y = mousePos.y;
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(Model, true);
  
          if (intersects.length > 0) {
            isDragging = true;
            previousMousePosition = {
              x: event.clientX,
              timestamp: event.timeStamp
            };
            
            angularVelocity = 0;
          }
        }
  
        function onMouseMove(event) {
          if (isDragging && Model) {
            const deltaX = event.clientX - previousMousePosition.x;
  
            
            Model.rotation.y += deltaX * DRAG_ROTATION_SCALE;
  
            
            let flingVel = deltaX * DRAG_ROTATION_SCALE;
            if (Math.abs(flingVel) > MAX_VELOCITY) {
              flingVel = Math.sign(flingVel) * MAX_VELOCITY;
            }
            angularVelocity = flingVel;
  
            previousMousePosition = {
              x: event.clientX,
              timestamp: event.timeStamp
            };
          }
        }
  
        function onMouseUp() {
          if (!Model || !isDragging) return;
          isDragging = false;
  
          
          
          
          if (Math.abs(angularVelocity) >= TURNTABLE_SPEED) {
            shouldClampToTurntable = true;
          } else {
            shouldClampToTurntable = false;
          }
        }
  
        container.addEventListener('mousedown', onMouseDown);
        container.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
  
        container.addEventListener('touchstart', onMouseDown);
        container.addEventListener('touchmove', onMouseMove);
        window.addEventListener('touchend', onMouseUp);
  
  
        
        function animate() {
          requestAnimationFrame(animate);
  
          
          if (!introStartTime) {
            introStartTime = performance.now();
          }
  
          if (Model) {
            
            if (!animationComplete) {
              const elapsed = (performance.now() - introStartTime) / 1000;
              let t = clamp01(elapsed / INTRO_TIME);
              t = easeOutQuad(t);
  
              
              const totalYDist = INTRO_Y_END - INTRO_Y_START;
              Model.position.y = INTRO_Y_START + totalYDist * t;
  
              
              Model.rotation.y = INTRO_ROT_OFFSET + (0 - INTRO_ROT_OFFSET) * t;
  
              if (elapsed >= INTRO_TIME) {
                Model.position.y = INTRO_Y_END;
                Model.rotation.y = 0;
                animationComplete = true;
              }
            }
            
            else {
              
              if (!isDragging) {
                
                angularVelocity *= FRICTION;
  
                
                if (shouldClampToTurntable) {
                  
                  if (Math.abs(angularVelocity) < TURNTABLE_SPEED) {
                    angularVelocity = Math.sign(angularVelocity) * TURNTABLE_SPEED;
                    
                  }
                } else {
                  
                  if (Math.abs(angularVelocity) < MIN_VELOCITY) {
                    angularVelocity = 0;
                  }
                }
  
                
                Model.rotation.y += angularVelocity;
              }
            }
          }
  
          renderer.render(scene, camera);
        }
        animate();
  
        
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
          const w = container.clientWidth;
          const h = container.clientHeight;
          renderer.setSize(w, h);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        }

        var layoutElement = document.getElementById('layoutName');
        if (layoutElement) {
            layoutElement.innerHTML = 'Latest 3D Layout: Limb.html';
        }
      }
  
      
      document.addEventListener('DOMContentLoaded', init);
      barba.hooks.after(init);
  
      let lastFrameTime = performance.now();
      const frameTimes = [];
      const maxSamples = 10; 
  
      function updateFrameTime() {
          const now = performance.now();
          const frameTime = now - lastFrameTime;
          lastFrameTime = now;
  
          
          frameTimes.push(frameTime);
  
          
          if (frameTimes.length > maxSamples) {
              frameTimes.shift(); 
          }
  
          
          const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
  
          
          document.getElementById('frameGenTime').textContent = `Frame Gen Time: ${avgFrameTime.toFixed(1)}ms`;
  
          requestAnimationFrame(updateFrameTime);
      }
  
      
      requestAnimationFrame(updateFrameTime);
  
    </script>
  </body>
</html>