<!doctype html>
<html>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=Playwrite+GB+S:ital,wght@0,100..400;1,100..400&display=swap" rel="stylesheet">
  <head>
    {% include head.html %}
  </head>
  <body data-barba="wrapper">
    {{ content }}
    <script type="module">
      import * as THREE from '/assets/js/threejs/three.module.min.js';
      import { GLTFLoader } from '/assets/js/GLTFLoader.js';
    
      
      
      
      
      const WAYPOINT_PARAMS = {
        fontFamily: 'Inter, sans-serif',
        fontWeight: 'bold',
        fontSize: '2rem',
        textColor: '#666',
        textOpacity: 1,             
        underlineColor: '#666',
        underlineThickness: '2px',  
        opacityTransitionTime: 0.3  
      };
    
      
      const markers = [];
      let waypointContainer;
      let svgOverlay;
    
      
      let raycaster, mouse;
      const clickableMeshes = [];
      let hoveredPart = null;  
    
      
      const pageMapping = {
        head: "/limbs/head.html",
        core: "/limbs/chest.html",
        arms: "/limbs/arms.html",
        legs: "/limbs/legs.html"
      };
    
      
      const DEFAULT_MESH_COLOR = new THREE.Color(0xe7e7e7); 
      const NON_HOVERED_MESH_COLOR = new THREE.Color(0xa2a2a2); 
    
      
      let lastColorUpdateTime = performance.now();
    
      
      
      
      function navigateTo(url) {
        if (typeof barba !== 'undefined' && typeof barba.go === 'function') {
          barba.go(url);
        } else {
          window.location.href = url;
        }
      }
    
      
      
      
      
      
      
      
      
      function createWaypointMarker(text, textCenter, lineTarget, alignment = 'center', assoc) {
        const marker = { text, textCenter, lineTarget, alignment, assoc };
    
        
        const markerDiv = document.createElement('div');
        markerDiv.classList.add('waypoint-marker');
        markerDiv.textContent = text;
        markerDiv.style.position = 'absolute';
        markerDiv.style.fontFamily = WAYPOINT_PARAMS.fontFamily;
        markerDiv.style.fontWeight = WAYPOINT_PARAMS.fontWeight;
        markerDiv.style.fontSize = WAYPOINT_PARAMS.fontSize;
        markerDiv.style.color = WAYPOINT_PARAMS.textColor;
        markerDiv.style.opacity = WAYPOINT_PARAMS.textOpacity;
        
        markerDiv.style.pointerEvents = 'auto';
        markerDiv.style.cursor = 'pointer';
        
        markerDiv.style.borderBottom = `${WAYPOINT_PARAMS.underlineThickness} solid ${WAYPOINT_PARAMS.underlineColor}`;
        markerDiv.style.textAlign = alignment;
        
        markerDiv.style.transition = `opacity ${WAYPOINT_PARAMS.opacityTransitionTime}s, color ${WAYPOINT_PARAMS.opacityTransitionTime}s`;
    
        
        markerDiv.addEventListener('mouseenter', (e) => {
          hoveredPart = marker.assoc;
          updateWaypointStyles();
          document.getElementById('hanger').style.cursor = 'pointer';
        });
        markerDiv.addEventListener('mouseleave', (e) => {
          hoveredPart = null;
          updateWaypointStyles();
          document.getElementById('hanger').style.cursor = 'default';
        });
        
        markerDiv.addEventListener('click', (e) => {
          e.stopPropagation();
          navigateTo(pageMapping[marker.assoc]);
        });
    
        waypointContainer.appendChild(markerDiv);
        marker.element = markerDiv;
    
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        
        line.setAttribute('stroke', WAYPOINT_PARAMS.underlineColor);
        
        line.style.transition = `opacity ${WAYPOINT_PARAMS.opacityTransitionTime}s`;
        
        line.setAttribute('stroke-width', WAYPOINT_PARAMS.underlineThickness.replace('px',''));
        
        line.style.opacity = '1';
        svgOverlay.appendChild(line);
        marker.lineElement = line;
    
        markers.push(marker);
      }
    
      
      
      
      function updateWaypointMarkers() {
        markers.forEach(marker => {
          
          const width = marker.element.offsetWidth;
          const height = marker.element.offsetHeight;
          
          
          let left;
          if (marker.alignment === 'left') {
            left = marker.textCenter.x;
          } else if (marker.alignment === 'right') {
            left = marker.textCenter.x - width;
          } else { 
            left = marker.textCenter.x - width / 2;
          }
          const top = marker.textCenter.y - height / 2;
          marker.element.style.transform = `translate(${left}px, ${top}px)`;
    
          
          let startX;
          if (marker.alignment === 'left') {
            startX = left; 
          } else if (marker.alignment === 'right') {
            startX = left + width; 
          } else { 
            startX = left + width / 2; 
          }
          const startY = top + height; 
    
          
          marker.lineElement.setAttribute('x1', startX);
          marker.lineElement.setAttribute('y1', startY);
          marker.lineElement.setAttribute('x2', marker.lineTarget.x);
          marker.lineElement.setAttribute('y2', marker.lineTarget.y);
        });
      }
    
      
      
      
      
      function updateWaypointStyles() {
        markers.forEach(marker => {
          if (hoveredPart && marker.assoc === hoveredPart) {
            marker.element.style.opacity = 1;
            marker.element.style.color = "#000";
            marker.lineElement.style.opacity = 1;
          } else if (hoveredPart) {
            marker.element.style.opacity = 0.3;
            marker.element.style.color = WAYPOINT_PARAMS.textColor;
            marker.lineElement.style.opacity = 0.3;
          } else {
            marker.element.style.opacity = 1;
            marker.element.style.color = WAYPOINT_PARAMS.textColor;
            marker.lineElement.style.opacity = 1;
          }
        });
      }
    
      
      
      
      function updateMeshColors() {
        const now = performance.now();
        let delta = now - lastColorUpdateTime;
        
        
        let lerpFactor = delta / (WAYPOINT_PARAMS.opacityTransitionTime * 1000);
        if (lerpFactor > 1) lerpFactor = 1;
    
        clickableMeshes.forEach(mesh => {
          let target;
          if (!hoveredPart || mesh.userData.part === hoveredPart) {
            target = DEFAULT_MESH_COLOR;
          } else {
            target = NON_HOVERED_MESH_COLOR;
          }
          mesh.material.color.lerp(target, lerpFactor);
        });
        lastColorUpdateTime = now;
      }
    
      
      
      
      function onDocumentMouseMove(event) {
        
        if (event.target.classList.contains('waypoint-marker')) {
          return;
        }
        const containerElem = document.getElementById('hanger');
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(clickableMeshes, true);
        if (intersects.length > 0) {
          const intersected = intersects[0].object;
          const part = intersected.userData.part;
          if (hoveredPart !== part) {
            hoveredPart = part;
            updateWaypointStyles();
          }
          containerElem.style.cursor = 'pointer';
        } else {
          hoveredPart = null;
          updateWaypointStyles();
          containerElem.style.cursor = 'default';
        }
      }
    
      function onDocumentClick(event) {
        
        if (event.target.classList.contains('waypoint-marker')) {
          return;
        }
        if (hoveredPart) {
          navigateTo(pageMapping[hoveredPart]);
        }
      }
    
      
      
      
      let renderer, camera; 
      function init() {
        const container = document.getElementById('hanger');
        if (!container) return;
    
        
        waypointContainer = document.createElement('div');
        waypointContainer.id = 'waypointContainer';
        waypointContainer.style.position = 'absolute';
        waypointContainer.style.top = '0';
        waypointContainer.style.left = '0';
        waypointContainer.style.width = '100%';
        waypointContainer.style.height = '100%';
        
        container.appendChild(waypointContainer);
    
        svgOverlay = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svgOverlay.id = 'svgOverlay';
        svgOverlay.style.position = 'absolute';
        svgOverlay.style.top = '0';
        svgOverlay.style.left = '0';
        svgOverlay.style.width = '100%';
        svgOverlay.style.height = '100%';
        svgOverlay.style.pointerEvents = 'none';
        container.appendChild(svgOverlay);
    
        
        
        
        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientHeight * 1.2, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);
    
        camera = new THREE.OrthographicCamera(
          -12 * 1.2, 12 * 1.2,
          12, -12,
          1, 1000
        );
        camera.position.set(29, 17.5, 32);
        camera.rotation.x = -16 * (Math.PI / 180);
        camera.rotation.y = 40 * (Math.PI / 180);
        camera.rotation.z = 11 * (Math.PI / 180);
    
        const scene = new THREE.Scene();
    
        
        const directionalLight = new THREE.DirectionalLight(0xEFF1F5, 2);
        directionalLight.position.set(5, 30, 30);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        directionalLight.shadow.camera.near = 0.1;
        directionalLight.shadow.camera.far = 500;
        directionalLight.shadow.bias = -0.0006;
        scene.add(directionalLight);
    
        const ambientLight = new THREE.AmbientLight(0xEFF1F5, 2);
        scene.add(ambientLight);
    
        
        const planeGeometry = new THREE.PlaneGeometry(20, 25);
        const planeMaterial = new THREE.ShadowMaterial();
        planeMaterial.opacity = 0.2;
        const plane = new THREE.Mesh(planeGeometry, planeMaterial);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        plane.position.z = -8;
        scene.add(plane);
    
        
        
        
        let Head = null, Core = null, Arms = null, Legs = null;
        const cast = true, recv = true;
        const ModelLoader = new GLTFLoader();
    
        
        function processModel(gltf, partName) {
          const group = gltf.scene;
          group.traverse(child => {
            if (child.isMesh) {
              child.castShadow = cast;
              child.receiveShadow = recv;
              child.material.color.set(0xe7e7e7);
              child.userData.part = partName;
              clickableMeshes.push(child);
            }
          });
          scene.add(group);
          return group;
        }
    
        ModelLoader.load('/assets/models/Full/Head.glb', function (gltf) {
          Head = processModel(gltf, 'head');
        }, undefined, function (error) { console.error(error); });
    
        ModelLoader.load('/assets/models/Full/Core.glb', function (gltf) {
          Core = processModel(gltf, 'core');
        }, undefined, function (error) { console.error(error); });
    
        ModelLoader.load('/assets/models/Full/Arms.glb', function (gltf) {
          Arms = processModel(gltf, 'arms');
        }, undefined, function (error) { console.error(error); });
    
        ModelLoader.load('/assets/models/Full/Legs.glb', function (gltf) {
          Legs = processModel(gltf, 'legs');
        }, undefined, function (error) { console.error(error); });
    
        
        
        
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
          const w = container.clientWidth;
          const h = container.clientHeight;
          renderer.setSize(w, h);
          camera.left = -w / 64;
          camera.right = w / 64;
          camera.top = h / 64;
          camera.bottom = -h / 64;
          camera.updateProjectionMatrix();
          updateWaypointMarkers();
        }
    
        
        
        
        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();
        container.addEventListener('mousemove', onDocumentMouseMove, false);
        container.addEventListener('click', onDocumentClick, false);
    
        
        
        
        function animate() {
          requestAnimationFrame(animate);
          renderer.render(scene, camera);
          updateWaypointMarkers();
          updateMeshColors();
        }
        animate();
    
        
        
        
        
        
        
        
        
        createWaypointMarker('About Me', { x: 650, y: 100 }, { x: 585, y: 150 }, 'left', 'head');
        createWaypointMarker('Game Design', { x: 400, y: 300 }, { x: 470, y: 300 }, 'right', 'core');
        createWaypointMarker('Narrative Design', { x: 900, y: 450 }, { x: 820, y: 400 }, 'left', 'arms');
        createWaypointMarker('Technical Foundations', { x: 250, y: 600 }, { x: 390, y: 550 }, 'right', 'legs');
      
        var layoutElement = document.getElementById('layoutName');
        if (layoutElement) {
            layoutElement.innerHTML = 'Latest 3D Layout: Hanger.html';
        }
      }
    
      
      document.addEventListener('DOMContentLoaded', init);
      barba.hooks.after(init);
    
      
      
      
      let lastFrameTime = performance.now();
      const frameTimes = [];
      const maxSamples = 10;
      function updateFrameTime() {
        const now = performance.now();
        const frameTime = now - lastFrameTime;
        lastFrameTime = now;
        frameTimes.push(frameTime);
        if (frameTimes.length > maxSamples) {
          frameTimes.shift();
        }
        const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
        document.getElementById('frameGenTime').textContent = `Frame Gen Time: ${avgFrameTime.toFixed(1)}ms`;
        requestAnimationFrame(updateFrameTime);
      }
      requestAnimationFrame(updateFrameTime);
    </script>    
    <script type="module">
      
      import * as THREE from '/assets/js/threejs/three.module.min.js';
      import { GLTFLoader } from '/assets/js/GLTFLoader.js';
  
      /****************************************
       * TUNABLE PARAMETERS (ALL CAPS)
       ****************************************/
  
      
      const INTRO_TIME        = 3.0;   
      const INTRO_Y_START     = -8;
      const INTRO_Y_END       = 0;
      const INTRO_ROT_OFFSET  = -1;    
  
      
      const DRAG_ROTATION_SCALE = 0.005; 
      const MAX_VELOCITY        = 0.5;   
      const MIN_VELOCITY        = 0.001; 
      const FRICTION            = 0.9;   
  
      
      
      
      const TURNTABLE_RPM      = 6.0;
  
      
      const CAMERA_Z           = 15;
  
      /****************************************
       * HELPER: convert RPM to radians/frame
       ****************************************/
      function rpmToRadPerFrame(rpm) {
        
        
        
        return (rpm * 2 * Math.PI) / (60 * 60);
      }
      const TURNTABLE_SPEED = rpmToRadPerFrame(TURNTABLE_RPM);
  
      function init() {
        const container = document.getElementById('viewport');

        if(container == null){
          return;
        }
  
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(container.clientWidth * 2, container.clientHeight);
        container.appendChild(renderer.domElement);
      
        
        const camera = new THREE.PerspectiveCamera(
          30,
          container.clientWidth * 2 / container.clientHeight,
          0.1,
          1000
        );
        camera.position.z = CAMERA_Z;
  
        
        const scene = new THREE.Scene();
  
        
        const directionalLight = new THREE.DirectionalLight(0xEFF1F5, 3.64);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);
  
        const ambientLight = new THREE.AmbientLight(0xEFF1F5, 1.2);
        scene.add(ambientLight);
  
        
        let Model = null;

        const modelName = container.getAttribute('data-model') || "Head";
        const modelUrl = `/assets/models/${modelName}.glb`;
  
        const ModelLoader = new GLTFLoader();
        ModelLoader.load(modelUrl, function (gltf) {
          Model = gltf.scene;
  
          
          Model.position.y = INTRO_Y_START;
          Model.rotation.y = INTRO_ROT_OFFSET;
          Model.scale.set(0.9, 0.9, 0.9);
  
          scene.add(Model);
        }, undefined, function (error) {
          console.error(error);
        });
  
        
        let introStartTime = null;
        let animationComplete = false;
  
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let previousMousePosition = { x: 0, timestamp: 0 };
        
        
        let angularVelocity = 0;
  
        
        let shouldClampToTurntable = false;
  
        
        function clamp01(x) {
          return Math.min(1, Math.max(0, x));
        }
        function easeOutQuad(t) {
          return 1 - (1 - t) * (1 - t);
        }
  
        
        function getMousePosition(event) {
          const rect = container.getBoundingClientRect();
          return {
            x: ((event.clientX - rect.left) / rect.width) * 2 - 1,
            y: -((event.clientY - rect.top) / rect.height) * 2 + 1
          };
        }
  
        
        function onMouseDown(event) {
          if (!Model || !animationComplete) return;
  
          
          const mousePos = getMousePosition(event);
          mouse.x = mousePos.x;
          mouse.y = mousePos.y;
          raycaster.setFromCamera(mouse, camera);
          const intersects = raycaster.intersectObject(Model, true);
  
          if (intersects.length > 0) {
            isDragging = true;
            previousMousePosition = {
              x: event.clientX,
              timestamp: event.timeStamp
            };
            
            angularVelocity = 0;
          }
        }
  
        function onMouseMove(event) {
          if (isDragging && Model) {
            const deltaX = event.clientX - previousMousePosition.x;
  
            
            Model.rotation.y += deltaX * DRAG_ROTATION_SCALE;
  
            
            let flingVel = deltaX * DRAG_ROTATION_SCALE;
            if (Math.abs(flingVel) > MAX_VELOCITY) {
              flingVel = Math.sign(flingVel) * MAX_VELOCITY;
            }
            angularVelocity = flingVel;
  
            previousMousePosition = {
              x: event.clientX,
              timestamp: event.timeStamp
            };
          }
        }
  
        function onMouseUp() {
          if (!Model || !isDragging) return;
          isDragging = false;
  
          
          
          
          if (Math.abs(angularVelocity) >= TURNTABLE_SPEED) {
            shouldClampToTurntable = true;
          } else {
            shouldClampToTurntable = false;
          }
        }
  
        container.addEventListener('mousedown', onMouseDown);
        container.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
  
        container.addEventListener('touchstart', onMouseDown);
        container.addEventListener('touchmove', onMouseMove);
        window.addEventListener('touchend', onMouseUp);
  
  
        
        function animate() {
          requestAnimationFrame(animate);
  
          
          if (!introStartTime) {
            introStartTime = performance.now();
          }
  
          if (Model) {
            
            if (!animationComplete) {
              const elapsed = (performance.now() - introStartTime) / 1000;
              let t = clamp01(elapsed / INTRO_TIME);
              t = easeOutQuad(t);
  
              
              const totalYDist = INTRO_Y_END - INTRO_Y_START;
              Model.position.y = INTRO_Y_START + totalYDist * t;
  
              
              Model.rotation.y = INTRO_ROT_OFFSET + (0 - INTRO_ROT_OFFSET) * t;
  
              if (elapsed >= INTRO_TIME) {
                Model.position.y = INTRO_Y_END;
                Model.rotation.y = 0;
                animationComplete = true;
              }
            }
            
            else {
              
              if (!isDragging) {
                
                angularVelocity *= FRICTION;
  
                
                if (shouldClampToTurntable) {
                  
                  if (Math.abs(angularVelocity) < TURNTABLE_SPEED) {
                    angularVelocity = Math.sign(angularVelocity) * TURNTABLE_SPEED;
                    
                  }
                } else {
                  
                  if (Math.abs(angularVelocity) < MIN_VELOCITY) {
                    angularVelocity = 0;
                  }
                }
  
                
                Model.rotation.y += angularVelocity;
              }
            }
          }
  
          renderer.render(scene, camera);
        }
        animate();
  
        
        window.addEventListener('resize', onWindowResize);
        function onWindowResize() {
          const w = container.clientWidth;
          const h = container.clientHeight;
          renderer.setSize(w, h);
          camera.aspect = w / h;
          camera.updateProjectionMatrix();
        }

        var layoutElement = document.getElementById('layoutName');
        if (layoutElement) {
            layoutElement.innerHTML = 'Latest 3D Layout: Limb.html';
        }
      }
  
      
      document.addEventListener('DOMContentLoaded', init);
      barba.hooks.after(init);
  
      let lastFrameTime = performance.now();
      const frameTimes = [];
      const maxSamples = 10; 
  
      function updateFrameTime() {
          const now = performance.now();
          const frameTime = now - lastFrameTime;
          lastFrameTime = now;
  
          
          frameTimes.push(frameTime);
  
          
          if (frameTimes.length > maxSamples) {
              frameTimes.shift(); 
          }
  
          
          const avgFrameTime = frameTimes.reduce((a, b) => a + b, 0) / frameTimes.length;
  
          
          document.getElementById('frameGenTime').textContent = `Frame Gen Time: ${avgFrameTime.toFixed(1)}ms`;
  
          requestAnimationFrame(updateFrameTime);
      }
  
      
      requestAnimationFrame(updateFrameTime);
  
    </script>
  </body>
</html>